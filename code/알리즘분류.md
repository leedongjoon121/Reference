## DFS / BFS
- 그래프 탐색 알고리즘
```
[문제유형]
1. 경로탐색 유형 (최단거리 , 시간)
2. 네트워크 유형 (연결)
3. 조합 유형 (모든 조합 만들기)
```
- DFS : 재귀함수 이용
 (재귀를 타고 타고 타서 탈출조건을 먼저 도달하고, 파라미터를 바꿔가며 정답을 찾는다.)
 - BFS : Queue / Linked List 이용
 (가장 먼저 넣은것을 꺼내서, 연결된 점을 Queue에 넣고, Queue가 빌때까지 반복)
 
- DFS가 구현하고 검증하기는 더쉬우나 한 케이스가 너무 오래걸리면 시간이 초과될 수 있다. 수행시간 관점에서는 복불복 일 수 있다. 한 조합을 다 끝까지 만들고 다음조합으로 넘어간다. 이에 반해 BFS는 모든 경우의 수를 한 단계씩 나아감, 그러나 평균적인 시간 복잡도가 낮다.

## DP (다이나믹 프로그래밍)
- 특정유형에만 국한되지 않고 다양한 문제를 최적화 할때 고려될 수 있는 알고리즘
- 1. DFS/BFS로 풀수는 있지만 경우의수가 너무 많은 문제
- 2. 경우의 수들에 중복적인 연산이 많은 경우 
  <br/>(현재 단계 까지는 연산을 잘 했는데, 그 연산을 또 하지 않으려면 어떤 정보를 남겨야 하는지 고민)
- 여태까지 최적의 답안을 쌓아간다는 방법으로 프로그래밍
<br/>

## Hash
- 모든 데이터 타입으로 접근이 가능
- 경우의 수 구하기 문제
- String을 기반으로 정보를 기록하고 관리해야 할때 는 Hash로 문제를 푼다.
  (데이터를 관리할때 String으로 관리해야 할 경우, 사람이나 사물 기준으로 문제 풀어야할때)
- String을 기준으로 정보를 기록하고 관리하려면, 단순 배열을 쓸순 없으니 Hash로 문제를 푼다.
- 대부분 key가 String타입으로 놓고 푼다.
- put / get / getOrDefault 함수를 주로 사용한다.
<br/>

## 브루트 포스 & 완전탐색 알고리즘
- 모든 경우의수를 다 시도해볼때
- 1. for / while 을 활용 
- 2. 재귀함수를 활용 (이게 가장 좋음)
  (소수 찾기 같은거)
<br/>

## DFS 혹은 완전 탐색으로 풀수있는 경우의 수
- 500만개 까지, 이거 넘어가면 안됨

## 코딩테스트 문제 유형 높은 순위
1. DFS/BFS : 정말 완벽하게 할줄 알아야 함
2. 문자열
3. 단순구현
4. 완전탐색
5. 해쉬

<br/> 이렇게 5개가 거의 75% 차지 <br/>

6. 다이나믹 프로그래밍
7. 재귀함수
8. 다익스트라

<br/> 이렇게 8개가 거의 88% 차지
