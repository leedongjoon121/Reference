# 데이터베이스 인덱스 (Database Index)
### <a href="http://jeong-pro.tistory.com/114?category=793347">출처</a>
### <a href="http://choko11.tistory.com/entry/%EC%9D%B8%EB%8D%B1%EC%8A%A4-1-%EA%B0%9C%EB%85%90%EC%A2%85%EB%A5%98%EC%A3%BC%EC%9D%98%EC%82%AC%ED%95%AD">출처2</a>

### 인덱스 : 어떤 데이터가 어디에 있다는 위치 정보를 가진 주소록
- 데이터들의 ROWID 정보를 별도의 세그먼트에 넣어 저장하고 관리

RDBMS에서 대용량의 데이터(레코드)가 있을 때, 특정 데이터를 검색하기 위해서 테이블의 레코드를 full scan하는 것이 아니라, 인덱스가 적용된 컬럼의 테이블(컬럼, 인덱스주소)을 따로 파일로 저장해놓고 그것을 검색해서 검색 효율을 높이는 방법

### 인덱스는 범위 스캔(Range Scan)을 한다.
- 인덱스는 키 컬럼순으로 정렬되어 있기 때문에 특정값을 찾다가 해당 범위를 넘어서는 값을 만나면 멈춘다. (=Range Scan)

### 인덱스에 가장 많이 사용되는 구조 = B-tree
- 인덱스를 저장하는 블럭들이 트리구조를 이루고 있다.
- root block과 branch block, leaf block이 있고, B-tree는 기본적으로 leaf block의 깊이가 모두 동일하게 균형(Balanced)이 잡혀있다.

## ![사진](https://github.com/leedongjoon121/Reference/blob/img/img/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA%202018-12-01%20%E1%84%8B%E1%85%A9%E1%84%92%E1%85%AE%202.37.40.png?raw=true)

leaf 블록간의 양방향 링크가 걸려있어서, 내림차순, 오름차순 검색이 쉽게 가능하다.

예를들어 between 10 and 20 이라는 조건이 있었으면 10을 찾은 후에 옆 링크로 타고가면서 값을 찾아올 수 있다.

### B-tree 인덱스 탐색과정
찾고자 하는 값이 branch block에서 가장 왼쪽 값보다 작거나 같을 때는 왼쪽 포인터, branch block 사이에 있으면 중앙 포인터, branch block에서 가장 큰 값보다 크면 오른쪽 포인터로 찾아간다.
이 과정을 통해 leaf block을 찾고 그 안에서 찾고자 하는 값이 있으면 성공이고 없으면 실패다.

### 테이블과 인덱스 비교
- 테이블은 컬럼이 여러개, 데이터가 정렬되지 않고 입력된 순서대로 들어감
 => 인덱스는 컬럼이 key 컬럼과 ROWID 컬럼 두개로 이루어져 있음(오름차순, 내림차순 정렬 가능) 

### 인덱스의 종류 (클러스터, 비클러스터)
1. 클러스터형 인덱스(Clustered Index) : 지정한 열에 대해 내용 자체가 "가나다" or "ABC"로 자동 정렬되어 있음, 한 테이블에 한 개만 생성 가능
2. 비클러스터형 인덱스(NonClustered Index) : 클러스터형 처럼 자동 정렬되지 않고, 한 테이블에 여러 개 생성 가능하다.

### 인덱스의 적용시기
인덱스는 select문의 where, join에서 좋은 성능을 발휘한다, 대신에 insert, update, delete문에서 성능이 떨어진다.

- insert문의 경우 새로운 데이터를 삽입하면서 테이블 뿐만아니라, 인덱스 테이블에도 생성을 해줘야 하며, 만약 인덱스의 leaf block이 꽉찼는데(정렬되어있음) 그 사이에 값이 들어온다면 다른 block으로 밀려나야할 데이터가 생기고, 이렇게되면 새로운 블럭에 key를 옮길 때 모든 과정이 redo에 기록되는 수고가 생긴다.

- delete문의 경우 기존 테이블에서는 그냥 레코드를 삭제하고, 그 공간을 다른 레코드가 사용할 수 있지만 인덱스 테이블은 사용 안함 표시만 하고 자리를 그대로 차지하기 때문에 유념해야 함.

- update문은 delete하고 insert하는 식으로 처리하기 때문에 insert, delete문이 인덱스에 동시에 작용하기 때문에 부하가 많아짐.

#### 결론은 검색(select)이 많고 insert, update, delete문이 적게 일어나는 테이블에서 인덱스를 사용하면 좋다.

<hr/>

#### 인덱스 컬럼의 분포가 좋아야(골고루 유일성을 갖게 분포)한다.
- 성별같이 남,여로 나눌 수 있는 컬럼에는 의미가 없고 사용하는 경우는 bitmap index를 적용할 때가 있음, 대용량 데이터 분석할 때 특정 성별만 뽑는다든지 할때 의미가 있음

만약 남,여 뿐만 아니라 추가로 컬럼의 종류가 생기면 bitmap index의 모든 맵을 수정해야 하는 큰 문제가 생김

#### 기타 인덱스 적용할 때 유의사항
- 인덱스 key(컬럼)은 가능하면 작게 설계
- 단일 인덱스 여러개를 사용해야할 때는 다중 컬럼 인덱스 생성을 고려
- 되도록 동등 비교(=)를 사용

